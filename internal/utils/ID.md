# Identifier Design

## Overview

Every entity in the system — such as `Company`, `Person`, `Product`, `StorageLocation`, `Purchase`, and `Sale` — uses a **dual-identifier** strategy:

1. **`ID`** → a unique, permanent system identifier (ULID).  
2. **`BusinessKey`** → a deterministic, versioned hash used for deduplication.

This design separates **technical identity** (for internal references) from **business identity** (for duplicate detection).

## 1. `ID` — Stable System Identifier

### Description

The `ID` field is a **ULID** (Universally Unique Lexicographically Sortable Identifier).  
It is automatically generated when a record is created and **never changes**.

A ULID is a 26-character, URL-safe string that encodes:

- A timestamp (first 48 bits) — for natural chronological ordering.  
- Random entropy (remaining 80 bits) — ensuring global uniqueness.

Example: `01HFYEVZQYF5Y2ZYQJ2TFTKX8X`


### Advantages

✅ **Globally unique** across all records and services.  
✅ **Lexicographically sortable** — newer records appear later in sorted order.  
✅ **Compact and URL-safe** — ideal for JSON and APIs.  
✅ **Immutable** — used for relationships between entities.  
✅ **Database-friendly** — less index fragmentation than UUID v4.

### Usage

- Used as the **primary key** for each record.  
- Used for **foreign key references** (e.g., `CompanyID`, `ProductID`).  
- Never changes, even if business details are updated.

## 2. `BusinessKey` — Deterministic Deduplication Key

### Description

The `BusinessKey` is a **deterministic, versioned hash** that represents the *unique business identity* of an entity (e.g., company name + registration number + city).

It is generated by hashing a canonicalized set of fields using SHA-256 and then base64-encoding the result.

Example: `C1_mNwUrsvcyRC3xYJkETh0gbhKDEcWy3hhl02xJgRMA`


- The prefix (`C1_`) indicates the **version** of the formula used to create it.  
- The remainder is a **base64-encoded hash**.

### Advantages

✅ **Deduplication** — identical `BusinessKey` values reveal duplicates.  
✅ **Versionable** — the formula can evolve safely.  
✅ **Deterministic** — same input → same key.  
✅ **Independent** from `ID` — changes won’t break references.

## 3. How `ID` and `BusinessKey` Work Together

| Purpose | Field | Example | Mutable? |
|----------|--------|----------|-----------|
| Permanent unique identifier | `ID` | `01HFYEVZQYF5Y2ZYQJ2TFTKX8X` | ❌ No |
| Business duplicate detector | `BusinessKey` | `C1_mNwUrsvcyRC3xYJkETh0gbhKDEcWy3hhl02xJgRMA` | ✅ Yes (versioned) |

### Creation Workflow

1. When a new record is created:
   - `ID` → generated ULID.  
   - `BusinessKey` → hash of selected fields.  
2. Before saving, the system checks whether the `BusinessKey` already exists.  
   - If **yes**, it’s a duplicate → reject.  
   - If **no**, it’s new → save and index both keys.  
3. When the `BusinessKey` formula changes, only new records use the new version (`C2_`, etc.).  
   Old data remains valid because `ID`s never change.

---

## 4. Example: Company Entity

```json
{
  "id": "01HFYEVZQYF5Y2ZYQJ2TFTKX8X",
  "business_key": "C1_mNwUrsvcyRC3xYJkETh0gbhKDEcWy3hhl02xJgRMA",
  "name": "Shell Trading B.V.",
  "coc_number": "12345678",
  "city": "Rotterdam",
  "address": "Energypark 10"
}
